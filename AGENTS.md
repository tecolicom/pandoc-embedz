# Repository Guidelines

## Project Structure & Module Organization
- `pandoc_embedz/` hosts the filter implementation (`filter.py`), constants like `SAVED_TEMPLATES`, and the `pandoc-embedz` console script entry point.
- `tests/` contains the `test_*.py` suites plus `tests/fixtures/` sample data; keep new coverage next to the behavior you want to lock down.
- `examples/` stores runnable Markdown that mirrors README scenarios; use it to verify CLI changes before updating docs.
- `build/`, `dist/`, and `pandoc_embedz.egg-info/` are packaging outputs generated by `python -m build`; do not commit them.

## Build, Test, and Development Commands
- `pip install -e .` links the package into your venv so changes take effect immediately.
- `pip install .[dev]` installs `pytest` and other dev extras defined under `[project.optional-dependencies]`.
- `python -m build` produces wheel and sdist artifacts in `dist/` for release candidates.
- `python -m pytest` uses the project `pyproject.toml` config (`-v`, `--strict-markers`, `--tb=short`) and automatically targets `tests/test_*.py`.
- `pandoc report.md --filter pandoc-embedz -o report.pdf` (or `pandoc-embedz` directly) exercises the filter in a realistic pipeline.

## Coding Style & Naming Conventions
- Keep Python code PEP 8-compliant: 4-space indentation, short helper functions (`snake_case`), and module-level constants in `CONSTANT_CASE`.
- Prefer explicit typing, docstrings, and config dictionaries similar to `parse_attributes` so intent stays clear.
- Use `pathlib.Path`, `validate_file_path`, and explicit checks every time you touch the filesystem, mirroring the existing security helpers.

## Testing Guidelines
- Tests live under `tests/` with `Test*` classes and `test_*` functions; name fixtures clearly and store shared data in `tests/fixtures/`.
- **IMPORTANT: Always run `python -m pytest tests/` (全テスト) before committing.** Running individual test files may miss failures in other test suites.
- Add coverage-sensitive scenarios (e.g., format detection, dot-notation parsing) as the filter evolves, and document the commands you used to validate them.

## Commit & Pull Request Guidelines
- **Before committing: Run `python -m pytest tests/` to ensure all tests pass.** This catches failures across all test suites.
- Follow the current git log style: start with a capitalized verb phrase, optionally separate a short summary from extra detail with a colon, and avoid terminal periods.
- PRs should target `main`, include a summary, list the commands you ran (tests, build, manual Pandoc runs), and link any related issues or examples.
- Mention manual verification steps (example Markdown, Pandoc output, etc.) so reviewers know what was exercised.

## Security & Configuration Tips
- Keep configuration tight: reuse `load_template_from_saved`/`validate_file_path` when reading external data so path traversal checks stay centralized.
- Store any new template snippets or CSV fixtures near the tests that validate them to make review easier.

## Filter Chaining & Code Block Generation

### Generating Code Blocks for Other Filters
embedz can generate code blocks (e.g., ```` ```{.table} ````) that are processed by subsequent filters like pantable:

- **How it works**: `pf.convert_text(result, input_format='markdown')` in `filter.py:743` parses the rendered template output and converts it to Pandoc AST elements, including CodeBlocks
- **Filter order**: Use `--filter pandoc-embedz --filter pantable` to chain filters; embedz runs first and generates code blocks, then pantable processes them
- **Requirements**: The embedz block must have data; blocks without data return empty list `[]` (see `filter.py:722-723`)

### Writing Triple Backticks in Templates

Use four backticks for the outer fence:
`````markdown
````{.embedz format=csv}
---
---
```{.table}
{% for row in data -%}
{{ row.product }},{{ row.sales }}
{% endfor -%}
```
---
product,sales
Widget,100
````
`````

- Use four backticks for the outer fence to write three backticks inside
- Empty YAML header `---` `---` is required (otherwise the inner `---` won't be recognized as data separator)
- This is standard Markdown syntax, no special handling needed

### Data Requirements
- **Inline data must come after the third `---`** (template/data separator)
- **Data in `with:` section is NOT treated as `data`**; it's only available as template variables
- If `data` is empty or `[]`, the filter returns `[]` with no output (by design; templates without data are considered "definitions")
- To iterate over data, use `{% for row in data %}`, not `{% for row in with.products %}`

### Query Template Expansion

SQL queries support Jinja2 template variable expansion, allowing you to share query logic across multiple embedz blocks:

**Define global variables:**
```markdown
```{.embedz}
---
global:
  start_date: '2024-01-01'
  end_date: '2024-12-31'
---
```
```

**Use in queries - Variable interpolation:**
```markdown
```{.embedz data=data.csv}
---
query: SELECT * FROM data WHERE date BETWEEN '{{ global.start_date }}' AND '{{ global.end_date }}'
---
Template here
```
```

**Use in queries - Complete query as variable:**
```markdown
```{.embedz}
---
global:
  period_filter: SELECT * FROM data WHERE date BETWEEN '2024-01-01' AND '2024-12-31'
---
```

```{.embedz data=sales.csv}
---
query: "{{ global.period_filter }}"
---
Template here
```
```

**Nested global variables:**

Global variable values can reference other global variables, enabling complex query composition:

```markdown
```{.embedz}
---
global:
  year: '2024'
  start_date: '{{ global.year }}-01-01'
  end_date: '{{ global.year }}-12-31'
  period_filter: SELECT * FROM data WHERE date BETWEEN '{{ global.start_date }}' AND '{{ global.end_date }}'
---
```
```

Variables are expanded in **definition order** during `GLOBAL_VARS.update()`:
- Each value is checked for `{{` or `{%`
- If found, it's rendered as a Jinja2 template using previously defined global variables
- This allows multi-level nesting (e.g., `year` → `start_date` → `period_filter`)

**Key points:**
- Template expansion occurs **before** data loading, so `global` and `with` variables are available
- Queries containing `{{` or `{%` are automatically processed as Jinja2 templates
- Global variable **values** are also expanded if they contain template syntax
- Variables are processed in definition order (later variables can reference earlier ones)
- The `global.` prefix is optional: `{{ start_date }}` and `{{ global.start_date }}` both work
- The `with.` prefix is also optional for local variables
- Use quotes around queries that start with `{{` to ensure valid YAML
- Works with CSV, TSV, SSV formats (via pandas SQL) and SQLite databases

### Macro Sharing Across Global Variables

Global variables support Jinja2 macro sharing using template inclusion. This enables defining reusable template functions once and using them across multiple variables.

**Define macros in a named template:**
```markdown
```{.embedz name=sql-macros}
{%- macro BETWEEN(start, end) -%}
SELECT * FROM data WHERE date BETWEEN '{{ start }}' AND '{{ end }}'
{%- endmacro -%}
```
```

**Import and use macros in global variables:**
```markdown
```{.embedz}
---
global:
  fiscal_year: 2024
  start_date: "{{ fiscal_year }}-04-01"
  end_date: "{{ fiscal_year + 1 }}-03-31"

  # Import macros from named template
  # Variable name can be anything; imports are recognized by {% from ... %} syntax
  _import: "{% from 'sql-macros' import BETWEEN %}"

  # Use imported macro
  yearly_query: "{{ BETWEEN(start_date, end_date) }}"
  quarterly_query: "{{ BETWEEN(quarter_start, quarter_end) }}"
---
```
```

**Implementation details:**
- Control structures (`{% macro %}`, `{% from ... import %}`, `{% include %}`) are automatically recognized and collected
- They are prepended to subsequent variable templates during rendering
- Leading newlines from non-output-producing control structures are stripped with `lstrip('\n')`
- Intentional leading/trailing spaces and tabs in variable values are preserved
- The Environment uses `FunctionLoader(load_template_from_saved)` to resolve template names
- Processing is sequential, so variables can reference earlier variables
- Control structures don't become variables themselves (they only affect subsequent variables)

**Use cases:**
- SQL query builders: Define query macros once, compose complex queries
- Date calculations: Macros for fiscal periods, quarters, date ranges
- Complex transformations: Encapsulate multi-step logic in reusable functions

**Note:** Macro sharing is only available in `global` variables, not `with` (local) variables. For block-specific formatting, define macros globally and reference them in templates.
